//! This module reads a Bitmap font embedded in a PostScript file as generated by
//! `dvips -V`, which appears in the source with a comment of `DVIPSBitmapFont`
use std::str::from_utf8_unchecked;

use nom::{
    branch::alt,
    bytes::complete::tag,
    character::complete::multispace0,
    character::complete::multispace1,
    character::complete::{char, digit1, hex_digit1},
    combinator::map,
    combinator::map_res,
    combinator::value,
    multi::count,
    multi::separated_list1,
    sequence::delimited,
    sequence::preceded,
    sequence::terminated,
    IResult,
};

#[derive(Debug)]
pub struct Font {
    pub len: usize,
    pub max: usize,
    pub chars: Vec<Char>,
}

fn from_dec(src: &str) -> Result<usize, std::num::ParseIntError> {
    usize::from_str_radix(src, 10)
}

fn parse_usize(input: &[u8]) -> IResult<&[u8], usize> {
    map_res(digit1, |b| {
        let src = unsafe { from_utf8_unchecked(b) };
        from_dec(src)
    })(input)
}

#[derive(Debug)]
pub struct Stream {
    pub inner: Vec<u8>,
}

pub fn parse_stream(input: &[u8]) -> IResult<&[u8], Stream> {
    let (input, parts): (&[u8], Vec<&[u8]>) = delimited(
        char('<'),
        separated_list1(multispace1, hex_digit1),
        char('>'),
    )(input)?;

    let mut iter = parts.into_iter().flat_map(|b| b.iter()).cloned();
    let mut inner = vec![];
    while let Some(first) = iter.next() {
        let second = iter.next().unwrap();
        let local = [first, second];
        let src = unsafe { std::str::from_utf8_unchecked(&local) };
        let byte = u8::from_str_radix(src, 16).unwrap();
        inner.push(byte);
    }

    Ok((input, Stream { inner }))
}

#[derive(Copy, Clone, Debug)]
pub enum Cmd {
    Inc,
    Digits(usize),
}

pub fn parse_cmd(input: &[u8]) -> IResult<&[u8], Cmd> {
    alt((
        value(Cmd::Inc, char('I')),
        map(
            terminated(parse_usize, preceded(multispace1, char('D'))),
            Cmd::Digits,
        ),
    ))(input)
}

#[derive(Debug)]
pub struct Char {
    pub stream: Stream,
    pub cmd: Cmd,
}

pub fn parse_char(input: &[u8]) -> IResult<&[u8], Char> {
    let (input, _) = multispace0(input)?;
    let (input, stream) = parse_stream(input)?;
    let (input, _) = multispace0(input)?;
    let (input, cmd) = parse_cmd(input)?;
    Ok((input, Char { stream, cmd }))
}

pub fn parse_fa(input: &[u8]) -> IResult<&[u8], Font> {
    let (input, _) = tag(b"/Fa")(input)?;
    let (input, _) = multispace1(input)?;
    let (input, len) = parse_usize(input)?;
    let (input, _) = multispace1(input)?;
    let (input, max) = parse_usize(input)?;
    let (input, _) = multispace1(input)?;
    let (input, _) = tag(b"df")(input)?;
    let (input, chars) = count(parse_char, len)(input)?;
    let (input, _) = multispace1(input)?;
    let (input, _) = char('E')(input)?;

    Ok((input, Font { len, max, chars }))
}
